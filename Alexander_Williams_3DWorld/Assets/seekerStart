using UnityEngine;
using System.Collections;
//including some .NET for dynamic arrays called List in C#
using System.Collections.Generic;
using System.Linq;


[RequireComponent(typeof(Steering))]
[RequireComponent(typeof(CharacterController))]
[RequireComponent(typeof(Dimensions))]


public class seekerStart : MonoBehaviour
{
	public GameObject target1  = null;
	public GameObject target2  = null;
	public Object dummyPrefab = null;
	public Object particlePrefab = null;
	public BuildGraph bg = null;
	// These weights will be exposed in the Inspector window
//	public float avoidDist = 30.0f;
	public float pathRadius = 1;
	public float seekWt = 10.0f;
	public float avoidWt = 30.0f;
	public float avoidDist = 1f;
	
	// Each vehicle contains a CharacterController which
	// makes it easier to deal with the relationship between
	// movement initiated by the character and the forces
	// generated by contact with the terrain & other game objects.
	public CharacterController characterController = null;
	
	// the steering component implements the basic steering functions
	private Steering steering = null;
	
	// movement variables
	private float gravity = 20.0f;
	private Vector3 moveDirection;

	//steering variable
	private Vector3 steeringForce;
	
	//reference to an array of obstacles
	//private  GameObject[] obstacles;
    public bool hasRock;
    private GameObject[] rocks;
	private GameObject heldRock;
	private GameObject wantedRock;
	private Vector3 rockPos;
	public bool HasRock { get{ return hasRock;} }
	private Vector3 startPos;
	
	private List<Vector3> pathFollow = new List<Vector3>();
	private GameObject[] obstacles;
	private List<GameObject> otherDudes = new List<GameObject>();
	private GameObject thatGuyIHate;
	bool alive = true;
	
	private int mask = 1 << 8 | 1 << 10;

	
	public void Start ()
	{
		//get component reference
		characterController = gameObject.GetComponent<CharacterController> ();
		steering = gameObject.GetComponent<Steering> ();
		moveDirection = transform.forward;
		obstacles = (GameObject.FindGameObjectsWithTag ("Obstacle"));
        rocks = (GameObject.FindGameObjectsWithTag("Rock"));
		Debug.Log(rocks.Count());
		mask = ~mask;
		foreach(GameObject g in GameObject.FindGameObjectsWithTag("Dude"))
		{
			otherDudes.Add(g);
		}

		startPos = transform.position;
        pathFollow = new List<Vector3>();
		//pathFollow = BuildGraph.instance.OtherSeekPath(transform.position, target1.transform.position);
		if(bg.cells == null)
		{
			bg.Scan();
		}
		Reposition();
	}
	
	public void RemoveDude(GameObject dude)
	{
		otherDudes.Remove(dude);
	}
	
	private void ClampSteering ()
	{
		if (steeringForce.magnitude > steering.maxForce) 
		{
			steeringForce.Normalize ();
            steeringForce *= steering.maxForce;
		}
	}
	
	// Update is called once per frame
	public void Update ()
	{
		CalcSteeringForce ();
		ClampSteering ();
		
		moveDirection = transform.forward * steering.Speed;
		// movedirection equals velocity
		//add acceleration
		moveDirection += steeringForce * Time.deltaTime;
		//modified for dt
		//update speed
		steering.Speed = moveDirection.magnitude;
		if (steering.Speed != moveDirection.magnitude) {
			moveDirection = moveDirection.normalized * steering.Speed;
		}
		//orient transform
		if (moveDirection != Vector3.zero)
			transform.forward = moveDirection;
		
		// Apply gravity
		moveDirection.y -= gravity;
		
		// the CharacterController moves us subject to physical constraints
		characterController.Move (moveDirection * Time.deltaTime);
	}
	
	void OnControllerColliderHit(ControllerColliderHit hit)
	{
		if(hit.gameObject.tag == "Rock" && hit.gameObject != heldRock) 
		{
			if(hit.gameObject.GetComponent<rock>().thrown)
			{
				goLimp(Vector3.zero);
			}
			else if(!hasRock)
			{
				Debug.Log("ROOOOOCK");
				heldRock = hit.gameObject;
				heldRock.GetComponent<rock>().held = true;
				heldRock.GetComponent<rock>().holder = gameObject;
				hasRock = true;
				wantedRock = null;
				pathFollow = null;
			}
		}
		if(hit.gameObject.tag == "Water")
		{
			goLimp(Vector3.zero);
		}
	}
	
	void CheckRocks()
	{
		rocks = (GameObject.FindGameObjectsWithTag("Rock"));
	}

	public Vector3 getPointOnPath(Vector3 p, Vector3 a, Vector3 b)
	{
		Vector3 ap = a - p;
		Vector3 ab = b - a;
		ab.Normalize();
		ab *= Vector3.Dot(ap, ab);
		return a + ab;
	}
	
	private Vector3 followPath(List<Vector3> path)
	{
		var futurePos = (transform.forward * characterController.velocity.magnitude) + transform.position;
		
		Vector3 pathTarget = Vector3.zero;
		Vector3 dir =  Vector3.zero;
		float distance = float.MaxValue;
		
		for(int i = 0; i < path.Count - 1; i++)
		{
			var p1 = path[i];
			var p2 = path[i+1];
			
			Vector3 point = getPointOnPath(futurePos, p1, p2);
			
			float d1 = Vector3.Distance(point, p1);
			float d2 = Vector3.Distance(point, p2);
			Vector3 line = p1 - p2;
			
			if(d1 + d2 > line.magnitude + 1) point = p2;
			
			float d = Vector3.Distance(futurePos, point);
			
			if(d < distance) 
			{
				distance = d;
				pathTarget = point;
				dir = line;
				dir.Normalize();
				dir *= 5;
			}
		}
		
		if(distance > pathRadius) 
		{
			//Debug.Log(pathTarget+dir); 
			return steering.Seek(pathTarget);
		}
		else return Vector3.zero;
	}
	
	private Vector3 segmentFollow(List<Vector3> path)
	{
		var futurePos = (transform.forward * characterController.velocity.magnitude) + transform.position;
		
		Vector3 pathTarget = Vector3.zero;
		Vector3 dir =  Vector3.zero;
		
		var p1 = path[0];
		var p2 = path[1];
		
		Vector3 point = getPointOnPath(futurePos, p1, p2);
		
		float d1 = Vector3.Distance(point, p1);
		float d2 = Vector3.Distance(point, p2);
		Vector3 line = p1 - p2;
		
		if(d1 + d2 > line.magnitude + 1) point = p2;
		
		float distance = Vector3.Distance(futurePos, point);
		
		pathTarget = point;
		dir = line;
		dir.Normalize();
		dir *= 5;
		
		
		if(distance > pathRadius) 
		{
			//Debug.Log(pathTarget+dir); 
			return steering.Seek(pathTarget);
		}
		else return Vector3.zero;
	}
	
	public void goLimp(Vector3 force)
	{
		/*GameObject dummy = (GameObject)Instantiate(dummyPrefab, transform.position, transform.rotation);
		dummy.rigidbody.AddForce(force, ForceMode.Impulse);*/
		foreach(GameObject dude in otherDudes)
		{
			if(dude != gameObject)
			{
				dude.GetComponent<seekerStart>().RemoveDude(gameObject);
			}
		}
		Instantiate(particlePrefab, transform.position, transform.rotation);
		Destroy(gameObject);
	}
	
	public void Reposition()
	{
		BuildGraph.GridPosition g = new BuildGraph.GridPosition();
			g.x = Random.Range(0, bg.cells.GetLength(0));
			g.y = Random.Range(0, bg.cells.GetLength(1));
			while(!bg.GetCell(g).walkable)
			{
				g.x = Random.Range(0, bg.cells.GetLength(0));
				g.y = Random.Range(0, bg.cells.GetLength(1));
			}
			Vector3 newPos = bg.GetWorldPosition(g);
			newPos.y = 100;
			transform.position = newPos;
	}
	
	private void CalcSteeringForce ()
	{
		steeringForce = Vector3.zero;
		/*if(Vector3.Distance(transform.position, target1.transform.position) < characterController.velocity.magnitude / 2)
		{
			pathFollow = BuildGraph.instance.OtherSeekPath(transform.position, target2.transform.position);
		}
		if(Vector3.Distance(transform.position, target2.transform.position) < characterController.velocity.magnitude / 2)
		{
			pathFollow = BuildGraph.instance.OtherSeekPath(transform.position, target1.transform.position);
		}*/
		/*if(pathFollow.Count < 2)
		{
			if(Vector3.Distance(transform.position, target1.transform.position) < Vector3.Distance(transform.position, target2.transform.position))
			{
				pathFollow = BuildGraph.instance.OtherSeekPath(transform.position, target2.transform.position);
			}
			else pathFollow = BuildGraph.instance.OtherSeekPath(transform.position, target1.transform.position);
		}*/
		//steeringForce += 2 * followPath(pathFollow); 
		if(!bg.GetCell(bg.GetGridPosition(transform.position)).walkable)
		{
			float record = float.MaxValue;
			Vector3 closest = new Vector3();
			foreach(GameObject o in obstacles)
			{
				steeringForce += avoidWt * steering.AvoidObstacle(o, avoidDist);
			}
		}
		else
		{
	        if (!hasRock)
	        {
				float record = float.MaxValue;
				GameObject newWantedRock = null;
				foreach(GameObject rock in rocks)
				{
					if(rock.rigidbody.IsSleeping() && bg.GetCell(bg.GetGridPosition(rock.transform.position)).walkable)
					{
						Vector3 heading = (rock.transform.position - transform.position).normalized;
						float dot = Vector3.Dot(transform.forward, heading);
						if(dot > .25)
						{
							RaycastHit hit = new RaycastHit();
							if(!Physics.Linecast(transform.position, rock.transform.position,out hit, mask))
							{
								Debug.DrawLine(transform.position, rock.transform.position);
								float distance = Vector3.Distance(transform.position, rock.transform.position);
								if(distance < record)
								{
									record = distance;
									newWantedRock = rock;
									rockPos = newWantedRock.transform.position;
								}
							}
							else Debug.DrawLine(transform.position, rock.transform.position, Color.red);
						}
					}
				}
				if(newWantedRock == null)
				{
					while(pathFollow == null || pathFollow.Count < 2)
					{
						BuildGraph.GridPosition g = new BuildGraph.GridPosition();
						g.x = Random.Range(0, bg.cells.GetLength(0));
						g.y = Random.Range(0, bg.cells.GetLength(1));
						if(bg.GetCell(g).walkable)
						{
							pathFollow = bg.OtherSeekPath(transform.position, bg.GetWorldPosition(g));
						}
					}
				}
				else if(newWantedRock != wantedRock)
				{
					wantedRock = newWantedRock;
					//pathFollow = bg.OtherSeekPath(transform.position, wantedRock.transform.position);
				}
				/*else
				{
					BuildGraph.GridCell g1 = bg.GetCell(bg.GetGridPosition(rockPos));
					BuildGraph.GridCell g2 = bg.GetCell(bg.GetGridPosition(wantedRock.transform.position));
					if(g1 != g2)
					{
						pathFollow = bg.OtherSeekPath(transform.position, wantedRock.transform.position);
					}
				}*/
				if(wantedRock != null)
				{
					if(!bg.GetCell(bg.GetGridPosition(wantedRock.transform.position)).walkable) wantedRock = null;
				}
				/*if(wantedRock != null)
				{
					if(pathFollow != null)
					{
						if(wantedRock.transform.position != rockPos)
						{
							pathFollow = null;
							rockPos = wantedRock.transform.position;
						}
					}
					if(pathFollow == null)
					{
						pathFollow = bg.OtherSeekPath(transform.position, wantedRock.transform.position);
					}
					Vector3 heading = (wantedRock.transform.position - transform.position).normalized;
					float dot = Vector3.Dot(transform.forward, heading);
					if(dot > .5)
					{
						RaycastHit hit = new RaycastHit();
						if(Physics.Linecast(transform.position, wantedRock.transform.position,out hit, mask))
						{
							wantedRock = null;
						}
					}
				}*/
				/*if(pathFollow == null || pathFollow.Count < 2)
				{
					List<Vector3> shortestPath;
					float closest = float.MaxValue;
					foreach(GameObject rock in rocks)
					{
						BuildGraph.GridPosition g2 = bg.GetGridPosition(rock.transform.position);
						if(bg.GetCell(g2).walkable)
						{
							shortestPath = bg.OtherSeekPath(transform.position, rock.transform.position);
							if(shortestPath != null)
							{
								if(shortestPath.Count < closest)
								{
			        	    		pathFollow = shortestPath;
									closest = pathFollow.Count;
								}
							}
						}
					}
				}*/
				/*foreach(GameObject dude in otherDudes)
				{
					if(dude.GetComponent<seekerStart>().hasRock)
					{
						Vector3 heading = (dude.transform.position - transform.position).normalized;
						float dot = Vector3.Dot(transform.forward, heading);
						if(dot > .5)
						{
							RaycastHit hit = new RaycastHit();
							if(!Physics.Linecast(transform.position, dude.transform.position,out hit, mask))
							{
								//Debug.Log("I see a dude.");
							}
						}
					}
				}*/
	        }
			else
			{
				foreach(GameObject dude in otherDudes)
				{
					Vector3 heading = (dude.transform.position - transform.position).normalized;
					float dot = Vector3.Dot(transform.forward, heading);
					if(dot > .5)
					{
						RaycastHit hit = new RaycastHit();
						if(!Physics.Linecast(transform.position, dude.transform.position,out hit, mask))
						{
							thatGuyIHate = dude;
							pathFollow = null;
						}
					}
				}
				if( thatGuyIHate == null)
				{
					while(pathFollow == null || pathFollow.Count < 2)
					{
						BuildGraph.GridPosition g = new BuildGraph.GridPosition();
						g.x = Random.Range(0, bg.cells.GetLength(0));
						g.y = Random.Range(0, bg.cells.GetLength(1));
						if(bg.GetCell(g).walkable)
						{
							pathFollow = bg.OtherSeekPath(transform.position, bg.GetWorldPosition(g));
						}
					}
				}
				if(thatGuyIHate != null)
				{
					/*if(pathFollow != null)
					{
						BuildGraph.GridPosition g = bg.GetGridPosition(thatGuyIHate.transform.position);
						BuildGraph.GridPosition pg = bg.GetGridPosition(pathFollow[pathFollow.Count]);
						if(bg.GetCell(pg) != bg.GetCell(g))
						{
							pathFollow = null;
						}
					}*/
					if(pathFollow == null || pathFollow.Count < 2)
					{
						pathFollow = bg.OtherSeekPath(transform.position, thatGuyIHate.transform.position);
					}
					if(Vector3.Distance(transform.position, thatGuyIHate.transform.position) < 50)
					{
						Vector3 heading = (thatGuyIHate.transform.position - transform.position).normalized;
						float dot = Vector3.Dot(transform.forward, heading);
						if(dot > .25)
						{
							RaycastHit hit = new RaycastHit();
							if(!Physics.Linecast(transform.position, thatGuyIHate.transform.position,out hit, mask))
							{
								Debug.DrawLine(transform.position, thatGuyIHate.transform.position);
								heldRock.GetComponent<rock>().held = false;
								heldRock.GetComponent<rock>().holder = null;
								/*Vector3 force = (thatGuyIHate.transform.position + 
									(thatGuyIHate.transform.forward * (thatGuyIHate.GetComponent<CharacterController>().velocity.magnitude / 8))) -
									transform.position;*/
								Vector3 force = thatGuyIHate.transform.position - transform.position;
								force += force.magnitude 
									* thatGuyIHate.transform.forward 
									* thatGuyIHate.GetComponent<CharacterController>().velocity.magnitude
									/ 100;
								//force.y = 0;
								force.Normalize();
								heldRock.rigidbody.AddForce(force * 100, ForceMode.Impulse);
								heldRock.GetComponent<rock>().thrown = true;
								thatGuyIHate = null;
								pathFollow = null;
							}
						}
					}
					if(heldRock != null)
					{
						if(heldRock.GetComponent<rock>().holder != gameObject)
						{
							heldRock = null;
							hasRock = false;
						}
					}
				}
			}
		}
		if(pathFollow != null && wantedRock == null)
		{ 
			if(pathFollow.Count > 1)
			{
				Debug.DrawLine(transform.position, pathFollow[0]);
				steeringForce += 2 * segmentFollow(pathFollow);
				if(Vector3.Distance(transform.position, pathFollow[0]) < characterController.velocity.magnitude / 2) pathFollow.RemoveAt(0);
				RaycastHit hit = new RaycastHit();
				if(Physics.Linecast(transform.position, pathFollow[0],out hit, mask))
				{
					pathFollow = null;
				}
			}
		}
		if(wantedRock != null) 
		{
			RaycastHit hit = new RaycastHit();
			if(!Physics.Linecast(transform.position, wantedRock.transform.position,out hit, mask))
			{
				steeringForce += seekWt * steering.Seek(wantedRock.transform.position);
			}
			else wantedRock = null;
		}
		
		/*foreach(GameObject o in obstacles)
		{
			steeringForce += avoidWt * steering.AvoidObstacle(o, avoidDist);
		}*/
		//steeringForce += seekWt * steering.Seek (target1.transform.position);
	}
	
}



